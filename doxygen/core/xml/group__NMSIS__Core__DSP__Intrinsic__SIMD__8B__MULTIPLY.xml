<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY" kind="group">
    <compoundname>NMSIS_Core_DSP_Intrinsic_SIMD_8B_MULTIPLY</compoundname>
    <title>SIMD 8-bit Multiply Instructions</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY_1ga4e14ca16506e0e4190fe003aba01d90f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long</type>
        <definition>__STATIC_FORCEINLINE unsigned long __RV_KHM8</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KHM8</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KHM8 (SIMD Signed Saturating Q7 Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KHM8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KHMX8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do Q7xQ7 element multiplications simultaneously. The Q14 results are then reduced to Q7 numbers again.</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KHM8</computeroutput> instruction, multiply the top 8-bit Q7 content of 16-bit chunks in Rs1 with the top 8-bit Q7 content of 16-bit chunks in Rs2. At the same time, multiply the bottom 8-bit Q7 content of 16-bit chunks in Rs1 with the bottom 8-bit Q7 content of 16-bit chunks in Rs2. For the <computeroutput>KHMX16</computeroutput> instruction, multiply the top 8-bit Q7 content of 16-bit chunks in Rs1 with the bottom 8-bit Q7 content of 16-bit chunks in Rs2. At the same time, multiply the bottom 8-bit Q7 content of 16-bit chunks in Rs1 with the top 8-bit Q7 content of 16-bit chunks in Rs2. The Q14 results are then right-shifted 7-bits and saturated into Q7 values. The Q7 results are then written into Rd. When both the two Q7 inputs of a multiplication are 0x80, saturation will happen. The result will be saturated to 0x7F and the overflow flag OV will be set.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">if<sp/>(is<sp/>`KHM8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.B[x];<sp/>op2b<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`KHMX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[x+1];<sp/>op2t<sp/>=<sp/>Rs2.H[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[x];<sp/>op2b<sp/>=<sp/>Rs2.H[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">for<sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(0x80<sp/>!=<sp/>aop<sp/>|<sp/>0x80<sp/>!=<sp/>bop)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(aop<sp/>s*<sp/>bop)<sp/>&gt;&gt;<sp/>7;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res=<sp/>0x7F;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.H[x/2]<sp/>=<sp/>concat(rest,<sp/>resb);</highlight></codeline>
<codeline><highlight class="normal">for<sp/>RV32,<sp/>x=0,2</highlight></codeline>
<codeline><highlight class="normal">for<sp/>RV64,<sp/>x=0,2,4,6</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" line="2202" column="1" bodyfile="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2202" bodyend="2207"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY_1ga147c294001e28791aaf5d757add3ff29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long</type>
        <definition>__STATIC_FORCEINLINE unsigned long __RV_KHMX8</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KHMX8</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KHMX8 (SIMD Signed Saturating Crossed Q7 Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KHM8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KHMX8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do Q7xQ7 element multiplications simultaneously. The Q14 results are then reduced to Q7 numbers again.</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KHM8</computeroutput> instruction, multiply the top 8-bit Q7 content of 16-bit chunks in Rs1 with the top 8-bit Q7 content of 16-bit chunks in Rs2. At the same time, multiply the bottom 8-bit Q7 content of 16-bit chunks in Rs1 with the bottom 8-bit Q7 content of 16-bit chunks in Rs2. For the <computeroutput>KHMX16</computeroutput> instruction, multiply the top 8-bit Q7 content of 16-bit chunks in Rs1 with the bottom 8-bit Q7 content of 16-bit chunks in Rs2. At the same time, multiply the bottom 8-bit Q7 content of 16-bit chunks in Rs1 with the top 8-bit Q7 content of 16-bit chunks in Rs2. The Q14 results are then right-shifted 7-bits and saturated into Q7 values. The Q7 results are then written into Rd. When both the two Q7 inputs of a multiplication are 0x80, saturation will happen. The result will be saturated to 0x7F and the overflow flag OV will be set.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">if<sp/>(is<sp/>`KHM8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.B[x];<sp/>op2b<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`KHMX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[x+1];<sp/>op2t<sp/>=<sp/>Rs2.H[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[x];<sp/>op2b<sp/>=<sp/>Rs2.H[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">for<sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(0x80<sp/>!=<sp/>aop<sp/>|<sp/>0x80<sp/>!=<sp/>bop)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(aop<sp/>s*<sp/>bop)<sp/>&gt;&gt;<sp/>7;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res=<sp/>0x7F;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.H[x/2]<sp/>=<sp/>concat(rest,<sp/>resb);</highlight></codeline>
<codeline><highlight class="normal">for<sp/>RV32,<sp/>x=0,2</highlight></codeline>
<codeline><highlight class="normal">for<sp/>RV64,<sp/>x=0,2,4,6</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" line="2264" column="1" bodyfile="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2264" bodyend="2269"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY_1gaa89f0815a309bf7e0c79c8ac9030c209" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_SMUL8</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_SMUL8</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMUL8 (SIMD Signed 8-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMUL8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMULX8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do signed 8-bit multiplications and generate four 16-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMUL8</computeroutput> instruction, multiply the 8-bit data elements of Rs1 with the corresponding 8-bit data elements of Rs2. For the <computeroutput>SMULX8</computeroutput> instruction, multiply the first and second 8-bit data elements of Rs1 with the second and first 8-bit data elements of Rs2. At the same time, multiply the third and fourth 8-bit data elements of Rs1 with the fourth and third 8-bit data elements of Rs2. The four 16-bit results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the two 16-bit results calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMUL8</computeroutput> instruction, multiply the 8-bit data elements of Rs1 with the corresponding 8-bit data elements of Rs2. For the <computeroutput>SMULX8</computeroutput> instruction, multiply the first and second 8-bit data elements of Rs1 with the second and first 8-bit data elements of Rs2. At the same time, multiply the third and fourth 8-bit data elements of Rs1 with the fourth and third 8-bit data elements of Rs2. The four 16-bit results are then written into Rd. The Rd.W[1] contains the two 16-bit results calculated from the top part of Rs1 and the Rd.W[0] contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`SMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`SMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/>=<sp/>op1t[x/2]<sp/>s*<sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/>=<sp/>op1b[x/2]<sp/>s*<sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H].H[1]<sp/>=<sp/>rest[1];<sp/>R[t_H].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">R[t_L].H[1]<sp/>=<sp/>rest[0];<sp/>R[t_L].H[0]<sp/>=<sp/>resb[0];</highlight></codeline>
<codeline><highlight class="normal">x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`SMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`SMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/>=<sp/>op1t[x/2]<sp/>s*<sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/>=<sp/>op1b[x/2]<sp/>s*<sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1].H[1]<sp/>=<sp/>rest[1];<sp/>Rd.W[1].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0].H[1]<sp/>=<sp/>rest[0];<sp/>Rd.W[0].H[0]<sp/>=<sp/>resb[0];</highlight></codeline>
<codeline><highlight class="normal">x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" line="9216" column="1" bodyfile="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" bodystart="9216" bodyend="9221"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY_1ga6960884895453cad6b8ac126b66ee892" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_SMULX8</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_SMULX8</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMULX8 (SIMD Signed Crossed 8-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMUL8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMULX8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do signed 8-bit multiplications and generate four 16-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMUL8</computeroutput> instruction, multiply the 8-bit data elements of Rs1 with the corresponding 8-bit data elements of Rs2. For the <computeroutput>SMULX8</computeroutput> instruction, multiply the first and second 8-bit data elements of Rs1 with the second and first 8-bit data elements of Rs2. At the same time, multiply the third and fourth 8-bit data elements of Rs1 with the fourth and third 8-bit data elements of Rs2. The four 16-bit results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the two 16-bit results calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMUL8</computeroutput> instruction, multiply the 8-bit data elements of Rs1 with the corresponding 8-bit data elements of Rs2. For the <computeroutput>SMULX8</computeroutput> instruction, multiply the first and second 8-bit data elements of Rs1 with the second and first 8-bit data elements of Rs2. At the same time, multiply the third and fourth 8-bit data elements of Rs1 with the fourth and third 8-bit data elements of Rs2. The four 16-bit results are then written into Rd. The Rd.W[1] contains the two 16-bit results calculated from the top part of Rs1 and the Rd.W[0] contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`SMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`SMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/>=<sp/>op1t[x/2]<sp/>s*<sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/>=<sp/>op1b[x/2]<sp/>s*<sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H].H[1]<sp/>=<sp/>rest[1];<sp/>R[t_H].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">R[t_L].H[1]<sp/>=<sp/>rest[0];<sp/>R[t_L].H[0]<sp/>=<sp/>resb[0];</highlight></codeline>
<codeline><highlight class="normal">x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`SMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`SMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/>=<sp/>op1t[x/2]<sp/>s*<sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/>=<sp/>op1b[x/2]<sp/>s*<sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1].H[1]<sp/>=<sp/>rest[1];<sp/>Rd.W[1].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0].H[1]<sp/>=<sp/>rest[0];<sp/>Rd.W[0].H[0]<sp/>=<sp/>resb[0];</highlight></codeline>
<codeline><highlight class="normal">x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" line="9299" column="1" bodyfile="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" bodystart="9299" bodyend="9304"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY_1ga119cf7edda88230d8d62fd642fff046b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_UMUL8</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_UMUL8</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>UMUL8 (SIMD Unsigned 8-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">UMUL8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">UMULX8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do unsigned 8-bit multiplications and generate four 16-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>UMUL8</computeroutput> instruction, multiply the unsigned 8-bit data elements of Rs1 with the corresponding unsigned 8-bit data elements of Rs2. For the <computeroutput>UMULX8</computeroutput> instruction, multiply the first and second unsigned 8-bit data elements of Rs1 with the second and first unsigned 8-bit data elements of Rs2. At the same time, multiply the third and fourth unsigned 8-bit data elements of Rs1 with the fourth and third unsigned 8-bit data elements of Rs2. The four 16-bit results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the two 16-bit results calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>UMUL8</computeroutput> instruction, multiply the unsigned 8-bit data elements of Rs1 with the corresponding unsigned 8-bit data elements of Rs2. For the <computeroutput>UMULX8</computeroutput> instruction, multiply the first and second unsigned 8-bit data elements of Rs1 with the second and first unsigned 8-bit data elements of Rs2. At the same time, multiply the third and fourth unsigned 8-bit data elements of Rs1 with the fourth and third unsigned 8-bit data elements of Rs2. The four 16-bit results are then written into Rd. The Rd.W[1] contains the two 16-bit results calculated from the top part of Rs1 and the Rd.W[0] contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`UMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`UMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/>=<sp/>op1t[x/2]<sp/>u*<sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/>=<sp/>op1b[x/2]<sp/>u*<sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H].H[1]<sp/>=<sp/>rest[1];<sp/>R[t_H].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">R[t_L].H[1]<sp/>=<sp/>rest[0];<sp/>R[t_L].H[0]<sp/>=<sp/>resb[0];</highlight></codeline>
<codeline><highlight class="normal">x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`UMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`UMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1b[x/2]<sp/><sp/>=<sp/><sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/><sp/>=<sp/><sp/>Rs2.B[x+1];<sp/><sp/>//<sp/><sp/>Rs1<sp/><sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/><sp/>=<sp/><sp/>op1t[x/2]<sp/><sp/>u*<sp/><sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/><sp/>=<sp/><sp/>op1b[x/2]<sp/><sp/>u*<sp/><sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/><sp/>=<sp/><sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/><sp/>=<sp/><sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1].H[1]<sp/>=<sp/>rest[1];<sp/>Rd.W[1].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0].H[1]<sp/>=<sp/>rest[0];<sp/>Rd.W[0].H[0]<sp/>=<sp/>resb[0];<sp/>x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" line="12481" column="1" bodyfile="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" bodystart="12481" bodyend="12486"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__8B__MULTIPLY_1gab655cbf1d89adb8bc28a1600d6e770aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_UMULX8</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_UMULX8</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>UMULX8 (SIMD Unsigned Crossed 8-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">UMUL8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">UMULX8<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do unsigned 8-bit multiplications and generate four 16-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>UMUL8</computeroutput> instruction, multiply the unsigned 8-bit data elements of Rs1 with the corresponding unsigned 8-bit data elements of Rs2. For the <computeroutput>UMULX8</computeroutput> instruction, multiply the first and second unsigned 8-bit data elements of Rs1 with the second and first unsigned 8-bit data elements of Rs2. At the same time, multiply the third and fourth unsigned 8-bit data elements of Rs1 with the fourth and third unsigned 8-bit data elements of Rs2. The four 16-bit results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the two 16-bit results calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>UMUL8</computeroutput> instruction, multiply the unsigned 8-bit data elements of Rs1 with the corresponding unsigned 8-bit data elements of Rs2. For the <computeroutput>UMULX8</computeroutput> instruction, multiply the first and second unsigned 8-bit data elements of Rs1 with the second and first unsigned 8-bit data elements of Rs2. At the same time, multiply the third and fourth unsigned 8-bit data elements of Rs1 with the fourth and third unsigned 8-bit data elements of Rs2. The four 16-bit results are then written into Rd. The Rd.W[1] contains the two 16-bit results calculated from the top part of Rs1 and the Rd.W[0] contains the two 16-bit results calculated from the bottom part of Rs1.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`UMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`UMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>Rs1<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/>=<sp/>op1t[x/2]<sp/>u*<sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/>=<sp/>op1b[x/2]<sp/>u*<sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H].H[1]<sp/>=<sp/>rest[1];<sp/>R[t_H].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">R[t_L].H[1]<sp/>=<sp/>rest[0];<sp/>R[t_L].H[0]<sp/>=<sp/>resb[0];</highlight></codeline>
<codeline><highlight class="normal">x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(is<sp/>`UMUL8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x+1];<sp/>//<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1b[x/2]<sp/>=<sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>if<sp/>(is<sp/>`UMULX8`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1t[x/2]<sp/>=<sp/>Rs1.B[x+1];<sp/>op2t[x/2]<sp/>=<sp/>Rs2.B[x];<sp/>//<sp/>Rs1<sp/>top</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>op1b[x/2]<sp/><sp/>=<sp/><sp/>Rs1.B[x];<sp/>op2b[x/2]<sp/><sp/>=<sp/><sp/>Rs2.B[x+1];<sp/><sp/>//<sp/><sp/>Rs1<sp/><sp/>bottom</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">rest[x/2]<sp/><sp/>=<sp/><sp/>op1t[x/2]<sp/><sp/>u*<sp/><sp/>op2t[x/2];</highlight></codeline>
<codeline><highlight class="normal">resb[x/2]<sp/><sp/>=<sp/><sp/>op1b[x/2]<sp/><sp/>u*<sp/><sp/>op2b[x/2];</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/><sp/>=<sp/><sp/>CONCAT(Rd(4,1),1&apos;b0);<sp/>t_H<sp/><sp/>=<sp/><sp/>CONCAT(Rd(4,1),1&apos;b1);</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1].H[1]<sp/>=<sp/>rest[1];<sp/>Rd.W[1].H[0]<sp/>=<sp/>resb[1];</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0].H[1]<sp/>=<sp/>rest[0];<sp/>Rd.W[0].H[0]<sp/>=<sp/>resb[0];<sp/>x<sp/>=<sp/>0<sp/>and<sp/>2</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" line="12565" column="1" bodyfile="/home/xl_ci/gitlab-runner/builds/f5c994c2/0/software/library/cmsis-5-riscv/CMSIS/nmsis_release/NMSIS/Core/Include/core_feature_dsp.h" bodystart="12565" bodyend="12570"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>SIMD 8-bit Multiply Instructions. </para>    </briefdescription>
    <detaileddescription>
<para>there are 6 SIMD 8-bit Multiply instructions. </para>    </detaileddescription>
  </compounddef>
</doxygen>
