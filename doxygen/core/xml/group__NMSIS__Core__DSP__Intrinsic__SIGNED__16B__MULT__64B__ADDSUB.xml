<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB" kind="group">
    <compoundname>NMSIS_Core_DSP_Intrinsic_SIGNED_16B_MULT_64B_ADDSUB</compoundname>
    <title>Signed 16-bit Multiply 64-bit Add/Subtract Instructions</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga4161cf3c9857cbef8d23b6a8e09b49d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMAL</definition>
        <argsstring>(long long a, unsigned long b)</argsstring>
        <name>__RV_SMAL</name>
        <param>
          <type>long long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMAL (Signed Multiply Halfs &amp; Add 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: Partial-SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMAL<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed bottom 16-bit content of the 32-bit elements of a register with the top 16-bit content of the same 32-bit elements of the same register, and add the results with a 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to another even/odd pair of registers (RV32) or a register (RV64).</para><para><bold>RV32 Description</bold>:<linebreak/>
This instruction multiplies the bottom 16-bit content of the lower 32-bit of Rs2 with the top 16-bit content of the lower 32-bit of Rs2 and adds the result with the 64-bit value of an even/odd pair of registers specified by Rs1(4,1). The 64-bit addition result is written back to an even/odd pair of registers specified by Rd(4,1). The 16-bit values of Rs2, and the 64-bit value of the Rs1(4,1) register- pair are treated as signed integers. Rx(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
This instruction multiplies the bottom 16-bit content of the 32-bit elements of Rs2 with the top 16-bit content of the same 32-bit elements of Rs2 and adds the results with the 64-bit value of Rs1. The 64- bit addition result is written back to Rd. The 16-bit values of Rs2, and the 64-bit value of Rs1 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs2.H[1]<sp/>*<sp/>Rs2.H[0];</highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rs1(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rs1(4,1),1&apos;</highlight><highlight class="normal">b1);<sp/>+</highlight></codeline>
<codeline><highlight class="normal">Idx2<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx3<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx3].R[Idx2]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">RV64:</highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs2.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs2.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[0];</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rs1<sp/>+<sp/>SE64(Mres[1][31:0])<sp/>+<sp/>SE64(Mres[0][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7297" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7297" bodyend="7302"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1gaceb791bc1a33f08f2abc7c5ec16c1a8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALBB</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALBB</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALBB (Signed Multiply Bottom Halfs &amp; Add 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALBB<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALBT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALTT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of the 32-bit elements of a register with the 16-bit content of the corresponding 32-bit elements of another register and add the results with a 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to the register-pair (RV32) or the register (RV64).<itemizedlist>
<listitem><para>SMALBB: rt pair + bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMALBT rt pair + bottom*top (all 32-bit elements)</para></listitem><listitem><para>SMALTT rt pair + top*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALBB</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2. For the <computeroutput>SMALBT</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMALTT</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2. The multiplication result is added with the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALBB</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALBT</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALTT</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The multiplication results are added with the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[0]<sp/>*<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>SMALBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[0]<sp/>*<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>SMALBT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[1]<sp/>*<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>SMALTT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALBT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALTT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1];</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres[0][31:0])<sp/>+<sp/>SE64(Mres[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7380" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7380" bodyend="7384"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga74fe212140384150726143f2f43c900f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALBT</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALBT</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALBT (Signed Multiply Bottom Half &amp; Top Half &amp; Add 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALBB<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALBT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALTT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of the 32-bit elements of a register with the 16-bit content of the corresponding 32-bit elements of another register and add the results with a 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to the register-pair (RV32) or the register (RV64).<itemizedlist>
<listitem><para>SMALBB: rt pair + bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMALBT rt pair + bottom*top (all 32-bit elements)</para></listitem><listitem><para>SMALTT rt pair + top*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALBB</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2. For the <computeroutput>SMALBT</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMALTT</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2. The multiplication result is added with the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALBB</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALBT</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALTT</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The multiplication results are added with the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[0]<sp/>*<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>SMALBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[0]<sp/>*<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>SMALBT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[1]<sp/>*<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>SMALTT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALBT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALTT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1];</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres[0][31:0])<sp/>+<sp/>SE64(Mres[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7462" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7462" bodyend="7466"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga39331e38421eb5f882a615941cf00444" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALTT</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALTT</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALTT (Signed Multiply Top Halfs &amp; Add 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALBB<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALBT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALTT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of the 32-bit elements of a register with the 16-bit content of the corresponding 32-bit elements of another register and add the results with a 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to the register-pair (RV32) or the register (RV64).<itemizedlist>
<listitem><para>SMALBB: rt pair + bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMALBT rt pair + bottom*top (all 32-bit elements)</para></listitem><listitem><para>SMALTT rt pair + top*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALBB</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2. For the <computeroutput>SMALBT</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMALTT</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2. The multiplication result is added with the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALBB</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALBT</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALTT</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The multiplication results are added with the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[0]<sp/>*<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>SMALBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[0]<sp/>*<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>SMALBT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>Rs1.H[1]<sp/>*<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>SMALTT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALBB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALBT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALTT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1];</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1];</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres[0][31:0])<sp/>+<sp/>SE64(Mres[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7544" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7544" bodyend="7548"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga8320e2679cb96ee46fcaf761925b8708" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALDA</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALDA</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALDA (Signed Multiply Two Halfs and Two Adds 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then adds the two 32-bit results and the 64-bit value of an even/odd pair of registers together.<itemizedlist>
<listitem><para>SMALDA: rt pair+ top*top + bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMALXDA: rt pair+ top*bottom + bottom*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALDA</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then adds the result to the result of multiplying the top 16-bit content of Rs1 with the top 16-bit content of Rs2 with unlimited precision. For the <computeroutput>SMALXDA</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then adds the result to the result of multiplying the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2 with unlimited precision. The result is added to the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64- bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64- bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32- bit elements of Rs2 with unlimited precision. For the <computeroutput>SMALXDA</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 with unlimited precision. The results are added to the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres0[31:0])<sp/>+<sp/>SE64(Mres1[31:0]);</highlight></codeline>
<codeline><highlight class="normal">RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres0[0][31:0])<sp/>+<sp/>SE64(Mres1[0][31:0])<sp/>+<sp/>SE64(Mres0[1][31:0])<sp/>+</highlight></codeline>
<codeline><highlight class="normal">SE64(Mres1[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7628" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7628" bodyend="7632"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga18e89f90f0b3e3d8c34ceb33b671a61b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALXDA</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALXDA</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALXDA (Signed Crossed Multiply Two Halfs and Two Adds 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then adds the two 32-bit results and the 64-bit value of an even/odd pair of registers together.<itemizedlist>
<listitem><para>SMALDA: rt pair+ top*top + bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMALXDA: rt pair+ top*bottom + bottom*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALDA</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then adds the result to the result of multiplying the top 16-bit content of Rs1 with the top 16-bit content of Rs2 with unlimited precision. For the <computeroutput>SMALXDA</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then adds the result to the result of multiplying the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2 with unlimited precision. The result is added to the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64- bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64- bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32- bit elements of Rs2 with unlimited precision. For the <computeroutput>SMALXDA</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 with unlimited precision. The results are added to the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres0[31:0])<sp/>+<sp/>SE64(Mres1[31:0]);</highlight></codeline>
<codeline><highlight class="normal">RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres0[0][31:0])<sp/>+<sp/>SE64(Mres1[0][31:0])<sp/>+<sp/>SE64(Mres0[1][31:0])<sp/>+</highlight></codeline>
<codeline><highlight class="normal">SE64(Mres1[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7712" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7712" bodyend="7716"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga68b7e1927e142a46a1e3132a7e04b777" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALDS</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALDS</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALDS (Signed Multiply Two Halfs &amp; Subtract &amp; Add 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALDRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then perform a subtraction operation between the two 32-bit results. Then add the subtraction result to the 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to the register-pair.<itemizedlist>
<listitem><para>SMALDS: rt pair + (top*top - bottom*bottom) (all 32-bit elements)</para></listitem><listitem><para>SMALDRS: rt pair + (bottom*bottom - top*top) (all 32-bit elements)</para></listitem><listitem><para>SMALXDS: rt pair + (top*bottom - bottom*top) (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALDS</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMALDRS</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2. For the <computeroutput>SMALXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2. The subtraction result is then added to the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALDRS</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The subtraction results are then added to the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1])<sp/>-<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);<sp/></highlight><highlight class="comment">//<sp/>SMALDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0])<sp/>-<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);<sp/></highlight><highlight class="comment">//<sp/>SMALDRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0])<sp/>-<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);<sp/></highlight><highlight class="comment">//<sp/>SMALXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1])<sp/>-<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[0].H[1])<sp/>-<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres[0][31:0])<sp/>+<sp/>SE64(Mres[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7803" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7803" bodyend="7807"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1ga9e334955371767a38c1e7069a42025c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALDRS</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALDRS</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALDRS (Signed Multiply Two Halfs &amp; Reverse Subtract &amp; Add 64- bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALDRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then perform a subtraction operation between the two 32-bit results. Then add the subtraction result to the 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to the register-pair.<itemizedlist>
<listitem><para>SMALDS: rt pair + (top*top - bottom*bottom) (all 32-bit elements)</para></listitem><listitem><para>SMALDRS: rt pair + (bottom*bottom - top*top) (all 32-bit elements)</para></listitem><listitem><para>SMALXDS: rt pair + (top*bottom - bottom*top) (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALDS</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMALDRS</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2. For the <computeroutput>SMALXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2. The subtraction result is then added to the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALDRS</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The subtraction results are then added to the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1])<sp/>-<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);<sp/></highlight><highlight class="comment">//<sp/>SMALDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0])<sp/>-<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);<sp/></highlight><highlight class="comment">//<sp/>SMALDRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0])<sp/>-<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);<sp/></highlight><highlight class="comment">//<sp/>SMALXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1])<sp/>-<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[0].H[1])<sp/>-<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres[0][31:0])<sp/>+<sp/>SE64(Mres[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7894" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7894" bodyend="7898"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1gaf31ec8bdff7f1f55254aaeb13979c70c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMALXDS</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMALXDS</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMALXDS (Signed Crossed Multiply Two Halfs &amp; Subtract &amp; Add 64- bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMALDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALDRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMALXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then perform a subtraction operation between the two 32-bit results. Then add the subtraction result to the 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The addition result is written back to the register-pair.<itemizedlist>
<listitem><para>SMALDS: rt pair + (top*top - bottom*bottom) (all 32-bit elements)</para></listitem><listitem><para>SMALDRS: rt pair + (bottom*bottom - top*top) (all 32-bit elements)</para></listitem><listitem><para>SMALXDS: rt pair + (top*bottom - bottom*top) (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMALDS</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMALDRS</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of Rs1 with the bottom 16-bit content of Rs2. For the <computeroutput>SMALXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2. The subtraction result is then added to the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit addition result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the operand and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the operand.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMALDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALDRS</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMALXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The subtraction results are then added to the 64-bit value of Rd. The 64-bit addition result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1])<sp/>-<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);<sp/></highlight><highlight class="comment">//<sp/>SMALDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0])<sp/>-<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);<sp/></highlight><highlight class="comment">//<sp/>SMALDRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0])<sp/>-<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);<sp/></highlight><highlight class="comment">//<sp/>SMALXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>+<sp/>SE64(Mres[31:0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1])<sp/>-<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[0].H[1])<sp/>-<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALDRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMALXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[0].H[0])<sp/>-<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>+<sp/>SE64(Mres[0][31:0])<sp/>+<sp/>SE64(Mres[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="7985" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="7985" bodyend="7989"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1gac49482a84d29e662acb7438c5821cc8b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMSLDA</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMSLDA</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMSLDA (Signed Multiply Two Halfs &amp; Add &amp; Subtract 64-bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMSLDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMSLXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then subtracts the two 32-bit results from the 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The subtraction result is written back to the register-pair.<itemizedlist>
<listitem><para>SMSLDA: rd pair - top*top - bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMSLXDA: rd pair - top*bottom - bottom*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMSLDA</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content Rs2 and multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMSLXDA</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2. The two multiplication results are subtracted from the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit subtraction result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the result and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the result.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMSLDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMSLXDA</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The four multiplication results are subtracted from the 64-bit value of Rd. The 64-bit subtraction result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>-<sp/>SE64(Mres0[31:0])<sp/>-<sp/>SE64(Mres1[31:0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>-<sp/>SE64(Mres0[0][31:0])<sp/>-<sp/>SE64(Mres1[0][31:0])<sp/>-<sp/>SE64(Mres0[1][31:0])<sp/>-</highlight></codeline>
<codeline><highlight class="normal">SE64(Mres1[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8999" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8999" bodyend="9003"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__64B__ADDSUB_1gad6cb1fab36698a107205e10b5ae71436" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long long</type>
        <definition>__STATIC_FORCEINLINE long long __RV_SMSLXDA</definition>
        <argsstring>(long long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMSLXDA</name>
        <param>
          <type>long long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMSLXDA (Signed Crossed Multiply Two Halfs &amp; Add &amp; Subtract 64- bit) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: DSP (64-bit Profile)</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMSLDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMSLXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then subtracts the two 32-bit results from the 64-bit value of an even/odd pair of registers (RV32) or a register (RV64). The subtraction result is written back to the register-pair.<itemizedlist>
<listitem><para>SMSLDA: rd pair - top*top - bottom*bottom (all 32-bit elements)</para></listitem><listitem><para>SMSLXDA: rd pair - top*bottom - bottom*top (all 32-bit elements)</para></listitem></itemizedlist>
</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMSLDA</computeroutput> instruction, it multiplies the bottom 16-bit content of Rs1 with the bottom 16-bit content Rs2 and multiplies the top 16-bit content of Rs1 with the top 16-bit content of Rs2. For the <computeroutput>SMSLXDA</computeroutput> instruction, it multiplies the top 16-bit content of Rs1 with the bottom 16-bit content of Rs2 and multiplies the bottom 16-bit content of Rs1 with the top 16-bit content of Rs2. The two multiplication results are subtracted from the 64-bit value of an even/odd pair of registers specified by Rd(4,1). The 64-bit subtraction result is written back to the register-pair. The 16-bit values of Rs1 and Rs2, and the 64-bit value of the register-pair are treated as signed integers. Rd(4,1), i.e., d, determines the even/odd pair group of the two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the high 32-bit of the result and the even <computeroutput>2d</computeroutput> register of the pair contains the low 32-bit of the result.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMSLDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMSLXDA</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The four multiplication results are subtracted from the 64-bit value of Rd. The 64-bit subtraction result is written back to Rd. The 16-bit values of Rs1 and Rs2, and the 64-bit value of Rd are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[31:0]<sp/>=<sp/>(Rs1.H[0]<sp/>*<sp/>Rs2.H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[31:0]<sp/>=<sp/>(Rs1.H[1]<sp/>*<sp/>Rs2.H[0]);</highlight></codeline>
<codeline><highlight class="normal">Idx0<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>Idx1<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[Idx1].R[Idx0]<sp/>=<sp/>R[Idx1].R[Idx0]<sp/>-<sp/>SE64(Mres0[31:0])<sp/>-<sp/>SE64(Mres1[31:0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>SMSLXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Mres0[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[0]<sp/>*<sp/>Rs2.W[0].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[0][31:0]<sp/>=<sp/>(Rs1.W[0].H[1]<sp/>*<sp/>Rs2.W[0].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Mres0[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[0]<sp/>*<sp/>Rs2.W[1].H[1]);</highlight></codeline>
<codeline><highlight class="normal">Mres1[1][31:0]<sp/>=<sp/>(Rs1.W[1].H[1]<sp/>*<sp/>Rs2.W[1].H[0]);</highlight></codeline>
<codeline><highlight class="normal">Rd<sp/>=<sp/>Rd<sp/>-<sp/>SE64(Mres0[0][31:0])<sp/>-<sp/>SE64(Mres1[0][31:0])<sp/>-<sp/>SE64(Mres0[1][31:0])<sp/>-</highlight></codeline>
<codeline><highlight class="normal">SE64(Mres1[1][31:0]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="9081" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="9081" bodyend="9085"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Signed 16-bit Multiply 64-bit Add/Subtract Instructions. </para>    </briefdescription>
    <detaileddescription>
<para>Signed 16-bit Multiply with 64-bit Add/Subtract Instructions.</para><para>there is Signed 16-bit Multiply 64-bit Add/Subtract Instructions</para><para>there are 10 Signed 16-bit Multiply with 64-bit Add/Subtract Instructions </para>    </detaileddescription>
  </compounddef>
</doxygen>
