<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY" kind="group">
    <compoundname>NMSIS_Core_DSP_Intrinsic_SIMD_16B_MULTIPLY</compoundname>
    <title>SIMD 16-bit Multiply Instructions</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY_1ga4d6124229f1e4e1bef085b9a1fad5414" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long</type>
        <definition>__STATIC_FORCEINLINE unsigned long __RV_KHM16</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KHM16</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KHM16 (SIMD Signed Saturating Q15 Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KHM16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KHMX16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do Q15xQ15 element multiplications simultaneously. The Q30 results are then reduced to Q15 numbers again.</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KHM16</computeroutput> instruction, multiply the top 16-bit Q15 content of 32-bit chunks in Rs1 with the top 16-bit Q15 content of 32-bit chunks in Rs2. At the same time, multiply the bottom 16-bit Q15 content of 32-bit chunks in Rs1 with the bottom 16-bit Q15 content of 32-bit chunks in Rs2. For the <computeroutput>KHMX16</computeroutput> instruction, multiply the top 16-bit Q15 content of 32-bit chunks in Rs1 with the bottom 16-bit Q15 content of 32-bit chunks in Rs2. At the same time, multiply the bottom 16-bit Q15 content of 32-bit chunks in Rs1 with the top 16-bit Q15 content of 32-bit chunks in Rs2. The Q30 results are then right-shifted 15-bits and saturated into Q15 values. The Q15 results are then written into Rd. When both the two Q15 inputs of a multiplication are 0x8000, saturation will happen. The result will be saturated to 0x7FFF and the overflow flag OV will be set.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`KHM16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[x+1];<sp/>op2t<sp/>=<sp/>Rs2.H[x+1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[x];<sp/>op2b<sp/>=<sp/>Rs2.H[x];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`KHMX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[x+1];<sp/>op2t<sp/>=<sp/>Rs2.H[x];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[x];<sp/>op2b<sp/>=<sp/>Rs2.H[x+1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(0x8000<sp/>!=<sp/>aop<sp/>|<sp/>0x8000<sp/>!=<sp/>bop)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(aop<sp/>s*<sp/>bop)<sp/>&gt;&gt;<sp/>15;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res=<sp/>0x7FFF;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x/2]<sp/>=<sp/>concat(rest,<sp/>resb);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=0,2</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2327" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2327" bodyend="2332"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY_1ga99ca71b2ac7b14ff937d4ca9946be3d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long</type>
        <definition>__STATIC_FORCEINLINE unsigned long __RV_KHMX16</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KHMX16</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KHMX16 (SIMD Signed Saturating Crossed Q15 Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KHM16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KHMX16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do Q15xQ15 element multiplications simultaneously. The Q30 results are then reduced to Q15 numbers again.</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KHM16</computeroutput> instruction, multiply the top 16-bit Q15 content of 32-bit chunks in Rs1 with the top 16-bit Q15 content of 32-bit chunks in Rs2. At the same time, multiply the bottom 16-bit Q15 content of 32-bit chunks in Rs1 with the bottom 16-bit Q15 content of 32-bit chunks in Rs2. For the <computeroutput>KHMX16</computeroutput> instruction, multiply the top 16-bit Q15 content of 32-bit chunks in Rs1 with the bottom 16-bit Q15 content of 32-bit chunks in Rs2. At the same time, multiply the bottom 16-bit Q15 content of 32-bit chunks in Rs1 with the top 16-bit Q15 content of 32-bit chunks in Rs2. The Q30 results are then right-shifted 15-bits and saturated into Q15 values. The Q15 results are then written into Rd. When both the two Q15 inputs of a multiplication are 0x8000, saturation will happen. The result will be saturated to 0x7FFF and the overflow flag OV will be set.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`KHM16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[x+1];<sp/>op2t<sp/>=<sp/>Rs2.H[x+1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[x];<sp/>op2b<sp/>=<sp/>Rs2.H[x];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`KHMX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[x+1];<sp/>op2t<sp/>=<sp/>Rs2.H[x];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[x];<sp/>op2b<sp/>=<sp/>Rs2.H[x+1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(0x8000<sp/>!=<sp/>aop<sp/>|<sp/>0x8000<sp/>!=<sp/>bop)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(aop<sp/>s*<sp/>bop)<sp/>&gt;&gt;<sp/>15;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res=<sp/>0x7FFF;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x/2]<sp/>=<sp/>concat(rest,<sp/>resb);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=0,2</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2390" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2390" bodyend="2395"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY_1gad0ccc8d1d7b5b8c0c2b7133b7243dc91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_SMUL16</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_SMUL16</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMUL16 (SIMD Signed 16-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMUL16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMULX16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do signed 16-bit multiplications and generate two 32-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMUL16</computeroutput> instruction, multiply the top 16-bit Q15 content of Rs1 with the top 16-bit Q15 content of Rs2. At the same time, multiply the bottom 16-bit Q15 content of Rs1 with the bottom 16-bit Q15 content of Rs2. For the <computeroutput>SMULX16</computeroutput> instruction, multiply the top 16-bit Q15 content of Rs1 with the bottom 16-bit Q15 content of Rs2. At the same time, multiply the bottom 16-bit Q15 content of Rs1 with the top 16- bit Q15 content of Rs2. The two Q30 results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the 32-bit result calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the 32-bit result calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMUL16</computeroutput> instruction, multiply the top 16-bit Q15 content of the lower 32-bit word in Rs1 with the top 16-bit Q15 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit Q15 content of the lower 32-bit word in Rs1 with the bottom 16-bit Q15 content of the lower 32-bit word in Rs2. For the <computeroutput>SMULX16</computeroutput> instruction, multiply the top 16-bit Q15 content of the lower 32-bit word in Rs1 with the bottom 16-bit Q15 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit Q15 content of the lower 32-bit word in Rs1 with the top 16-bit Q15 content of the lower 32-bit word in Rs2. The two 32-bit Q30 results are then written into Rd. The result calculated from the top 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[1]. And the result calculated from the bottom 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[0]</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>s*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">R[t_L]<sp/>=<sp/>resb;</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>s*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0]<sp/>=<sp/>resb;</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="9384" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="9384" bodyend="9389"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY_1ga2eb023a945b38fad971202a788f3899c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_SMULX16</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_SMULX16</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMULX16 (SIMD Signed Crossed 16-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMUL16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMULX16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do signed 16-bit multiplications and generate two 32-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>SMUL16</computeroutput> instruction, multiply the top 16-bit Q15 content of Rs1 with the top 16-bit Q15 content of Rs2. At the same time, multiply the bottom 16-bit Q15 content of Rs1 with the bottom 16-bit Q15 content of Rs2. For the <computeroutput>SMULX16</computeroutput> instruction, multiply the top 16-bit Q15 content of Rs1 with the bottom 16-bit Q15 content of Rs2. At the same time, multiply the bottom 16-bit Q15 content of Rs1 with the top 16- bit Q15 content of Rs2. The two Q30 results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the 32-bit result calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the 32-bit result calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>SMUL16</computeroutput> instruction, multiply the top 16-bit Q15 content of the lower 32-bit word in Rs1 with the top 16-bit Q15 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit Q15 content of the lower 32-bit word in Rs1 with the bottom 16-bit Q15 content of the lower 32-bit word in Rs2. For the <computeroutput>SMULX16</computeroutput> instruction, multiply the top 16-bit Q15 content of the lower 32-bit word in Rs1 with the bottom 16-bit Q15 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit Q15 content of the lower 32-bit word in Rs1 with the top 16-bit Q15 content of the lower 32-bit word in Rs2. The two 32-bit Q30 results are then written into Rd. The result calculated from the top 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[1]. And the result calculated from the bottom 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[0]</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>s*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">R[t_L]<sp/>=<sp/>resb;</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`SMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>s*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0]<sp/>=<sp/>resb;</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="9469" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="9469" bodyend="9474"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY_1ga0b8735b23131378b6bcad1dd67255513" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_UMUL16</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_UMUL16</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>UMUL16 (SIMD Unsigned 16-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">UMUL16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">UMULX16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do unsigned 16-bit multiplications and generate two 32-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>UMUL16</computeroutput> instruction, multiply the top 16-bit U16 content of Rs1 with the top 16-bit U16 content of Rs2. At the same time, multiply the bottom 16-bit U16 content of Rs1 with the bottom 16-bit U16 content of Rs2. For the <computeroutput>UMULX16</computeroutput> instruction, multiply the top 16-bit U16 content of Rs1 with the bottom 16-bit U16 content of Rs2. At the same time, multiply the bottom 16-bit U16 content of Rs1 with the top 16- bit U16 content of Rs2. The two U32 results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the 32-bit result calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the 32-bit result calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>UMUL16</computeroutput> instruction, multiply the top 16-bit U16 content of the lower 32-bit word in Rs1 with the top 16-bit U16 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit U16 content of the lower 32-bit word in Rs1 with the bottom 16-bit U16 content of the lower 32-bit word in Rs2. For the <computeroutput>UMULX16</computeroutput> instruction, multiply the top 16-bit U16 content of the lower 32-bit word in Rs1 with the bottom 16-bit U16 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit U16 content of the lower 32-bit word in Rs1 with the top 16-bit U16 content of the lower 32-bit word in Rs2. The two 32-bit U32 results are then written into Rd. The result calculated from the top 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[1]. And the result calculated from the bottom 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[0]</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>u*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">R[t_L]<sp/>=<sp/>resb;</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>u*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0]<sp/>=<sp/>resb;</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="12650" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="12650" bodyend="12655"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__MULTIPLY_1ga32ff52a5adf2d53a6d661c48ba6e58c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> unsigned long long</type>
        <definition>__STATIC_FORCEINLINE unsigned long long __RV_UMULX16</definition>
        <argsstring>(unsigned int a, unsigned int b)</argsstring>
        <name>__RV_UMULX16</name>
        <param>
          <type>unsigned int</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>UMULX16 (SIMD Unsigned Crossed 16-bit Multiply) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">UMUL16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">UMULX16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do unsigned 16-bit multiplications and generate two 32-bit results simultaneously.</para><para><bold>RV32 Description</bold>:<linebreak/>
For the <computeroutput>UMUL16</computeroutput> instruction, multiply the top 16-bit U16 content of Rs1 with the top 16-bit U16 content of Rs2. At the same time, multiply the bottom 16-bit U16 content of Rs1 with the bottom 16-bit U16 content of Rs2. For the <computeroutput>UMULX16</computeroutput> instruction, multiply the top 16-bit U16 content of Rs1 with the bottom 16-bit U16 content of Rs2. At the same time, multiply the bottom 16-bit U16 content of Rs1 with the top 16- bit U16 content of Rs2. The two U32 results are then written into an even/odd pair of registers specified by Rd(4,1). Rd(4,1), i.e., d, determines the even/odd pair group of two registers. Specifically, the register pair includes register 2d and 2d+1. The odd <computeroutput>2d+1</computeroutput> register of the pair contains the 32-bit result calculated from the top part of Rs1 and the even <computeroutput>2d</computeroutput> register of the pair contains the 32-bit result calculated from the bottom part of Rs1.</para><para><bold>RV64 Description</bold>:<linebreak/>
For the <computeroutput>UMUL16</computeroutput> instruction, multiply the top 16-bit U16 content of the lower 32-bit word in Rs1 with the top 16-bit U16 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit U16 content of the lower 32-bit word in Rs1 with the bottom 16-bit U16 content of the lower 32-bit word in Rs2. For the <computeroutput>UMULX16</computeroutput> instruction, multiply the top 16-bit U16 content of the lower 32-bit word in Rs1 with the bottom 16-bit U16 content of the lower 32-bit word in Rs2. At the same time, multiply the bottom 16-bit U16 content of the lower 32-bit word in Rs1 with the top 16-bit U16 content of the lower 32-bit word in Rs2. The two 32-bit U32 results are then written into Rd. The result calculated from the top 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[1]. And the result calculated from the bottom 16-bit of the lower 32-bit word in Rs1 is written to Rd.W[0]</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>RV32:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>u*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">t_L<sp/>=<sp/>CONCAT(Rd(4,1),1</highlight><highlight class="stringliteral">&apos;b0);<sp/>t_H<sp/>=<sp/>CONCAT(Rd(4,1),1&apos;</highlight><highlight class="normal">b1);</highlight></codeline>
<codeline><highlight class="normal">R[t_H]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">R[t_L]<sp/>=<sp/>resb;</highlight></codeline>
<codeline><highlight class="normal">*<sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMUL16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is<sp/>`UMULX16`)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1t<sp/>=<sp/>Rs1.H[1];<sp/>op2t<sp/>=<sp/>Rs2.H[0];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>top</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>op1b<sp/>=<sp/>Rs1.H[0];<sp/>op2b<sp/>=<sp/>Rs2.H[1];<sp/></highlight><highlight class="comment">//<sp/>Rs1<sp/>bottom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>((aop,bop,res)<sp/>in<sp/>[(op1t,op2t,rest),<sp/>(op1b,op2b,resb)])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>aop<sp/>u*<sp/>bop;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[1]<sp/>=<sp/>rest;</highlight></codeline>
<codeline><highlight class="normal">Rd.W[0]<sp/>=<sp/>resb;</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="12735" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="12735" bodyend="12740"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>SIMD 16-bit Multiply Instructions. </para>    </briefdescription>
    <detaileddescription>
<para>there are 6 SIMD 16-bit Multiply instructions. </para>    </detaileddescription>
  </compounddef>
</doxygen>
