<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="group__cmplx__dot__prod" kind="group">
    <compoundname>cmplx_dot_prod</compoundname>
    <title>Complex Dot Product</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__cmplx__dot__prod_1ga4a487e8090687e624d830878c50a6b72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void riscv_cmplx_dot_prod_f32</definition>
        <argsstring>(const float32_t *pSrcA, const float32_t *pSrcB, uint32_t numSamples, float32_t *realResult, float32_t *imagResult)</argsstring>
        <name>riscv_cmplx_dot_prod_f32</name>
        <param>
          <type>const float32_t *</type>
          <declname>pSrcA</declname>
        </param>
        <param>
          <type>const float32_t *</type>
          <declname>pSrcB</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>numSamples</declname>
        </param>
        <param>
          <type>float32_t *</type>
          <declname>realResult</declname>
        </param>
        <param>
          <type>float32_t *</type>
          <declname>imagResult</declname>
        </param>
        <briefdescription>
<para>Floating-point complex dot product. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pSrcA</parametername>
</parameternamelist>
<parameterdescription>
<para>points to the first input vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pSrcB</parametername>
</parameternamelist>
<parameterdescription>
<para>points to the second input vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">numSamples</parametername>
</parameternamelist>
<parameterdescription>
<para>number of samples in each vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">realResult</parametername>
</parameternamelist>
<parameterdescription>
<para>real part of the result returned here </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">imagResult</parametername>
</parameternamelist>
<parameterdescription>
<para>imaginary part of the result returned here </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>none </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/DSP/Source/ComplexMathFunctions/riscv_cmplx_dot_prod_f32.c" line="78" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/DSP/Source/ComplexMathFunctions/riscv_cmplx_dot_prod_f32.c" bodystart="78" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="group__cmplx__dot__prod_1gab1a7915b81aef73f226859c0fe835b37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void riscv_cmplx_dot_prod_q15</definition>
        <argsstring>(const q15_t *pSrcA, const q15_t *pSrcB, uint32_t numSamples, q31_t *realResult, q31_t *imagResult)</argsstring>
        <name>riscv_cmplx_dot_prod_q15</name>
        <param>
          <type>const q15_t *</type>
          <declname>pSrcA</declname>
        </param>
        <param>
          <type>const q15_t *</type>
          <declname>pSrcB</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>numSamples</declname>
        </param>
        <param>
          <type>q31_t *</type>
          <declname>realResult</declname>
        </param>
        <param>
          <type>q31_t *</type>
          <declname>imagResult</declname>
        </param>
        <briefdescription>
<para>Q15 complex dot product. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pSrcA</parametername>
</parameternamelist>
<parameterdescription>
<para>points to the first input vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pSrcB</parametername>
</parameternamelist>
<parameterdescription>
<para>points to the second input vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">numSamples</parametername>
</parameternamelist>
<parameterdescription>
<para>number of samples in each vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">realResult</parametername>
</parameternamelist>
<parameterdescription>
<para>real part of the result returned here </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">imagResult</parametername>
</parameternamelist>
<parameterdescription>
<para>imaginary part of the result returned her </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>none</para></simplesect>
<simplesect kind="par"><title>Scaling and Overflow Behavior</title><para>The function is implemented using an internal 64-bit accumulator. The intermediate 1.15 by 1.15 multiplications are performed with full precision and yield a 2.30 result. These are accumulated in a 64-bit accumulator with 34.30 precision. As a final step, the accumulators are converted to 8.24 format. The return results <computeroutput>realResult</computeroutput> and <computeroutput>imagResult</computeroutput> are in 8.24 format. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/DSP/Source/ComplexMathFunctions/riscv_cmplx_dot_prod_q15.c" line="58" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/DSP/Source/ComplexMathFunctions/riscv_cmplx_dot_prod_q15.c" bodystart="58" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="group__cmplx__dot__prod_1gae736f9f08fcf71e7a5c13ee4bbe1c33a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void riscv_cmplx_dot_prod_q31</definition>
        <argsstring>(const q31_t *pSrcA, const q31_t *pSrcB, uint32_t numSamples, q63_t *realResult, q63_t *imagResult)</argsstring>
        <name>riscv_cmplx_dot_prod_q31</name>
        <param>
          <type>const q31_t *</type>
          <declname>pSrcA</declname>
        </param>
        <param>
          <type>const q31_t *</type>
          <declname>pSrcB</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>numSamples</declname>
        </param>
        <param>
          <type>q63_t *</type>
          <declname>realResult</declname>
        </param>
        <param>
          <type>q63_t *</type>
          <declname>imagResult</declname>
        </param>
        <briefdescription>
<para>Q31 complex dot product. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pSrcA</parametername>
</parameternamelist>
<parameterdescription>
<para>points to the first input vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pSrcB</parametername>
</parameternamelist>
<parameterdescription>
<para>points to the second input vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">numSamples</parametername>
</parameternamelist>
<parameterdescription>
<para>number of samples in each vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">realResult</parametername>
</parameternamelist>
<parameterdescription>
<para>real part of the result returned here </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">imagResult</parametername>
</parameternamelist>
<parameterdescription>
<para>imaginary part of the result returned here </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>none</para></simplesect>
<simplesect kind="par"><title>Scaling and Overflow Behavior</title><para>The function is implemented using an internal 64-bit accumulator. The intermediate 1.31 by 1.31 multiplications are performed with 64-bit precision and then shifted to 16.48 format. The internal real and imaginary accumulators are in 16.48 format and provide 15 guard bits. Additions are nonsaturating and no overflow will occur as long as <computeroutput>numSamples</computeroutput> is less than 32768. The return results <computeroutput>realResult</computeroutput> and <computeroutput>imagResult</computeroutput> are in 16.48 format. Input down scaling is not required. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/DSP/Source/ComplexMathFunctions/riscv_cmplx_dot_prod_q31.c" line="59" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/DSP/Source/ComplexMathFunctions/riscv_cmplx_dot_prod_q31.c" bodystart="59" bodyend="150"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Computes the dot product of two complex vectors. The vectors are multiplied element-by-element and then summed.</para><para>The <computeroutput>pSrcA</computeroutput> points to the first complex input vector and <computeroutput>pSrcB</computeroutput> points to the second complex input vector. <computeroutput>numSamples</computeroutput> specifies the number of complex samples and the data in each array is stored in an interleaved fashion (real, imag, real, imag, ...). Each array has a total of <computeroutput>2*numSamples</computeroutput> values.</para><para>The underlying algorithm is used:</para><para><preformatted>
realResult = 0;
imagResult = 0;
for (n = 0; n &lt; numSamples; n++) {
    realResult += pSrcA[(2*n)+0] * pSrcB[(2*n)+0] - pSrcA[(2*n)+1] * pSrcB[(2*n)+1];
    imagResult += pSrcA[(2*n)+0] * pSrcB[(2*n)+1] + pSrcA[(2*n)+1] * pSrcB[(2*n)+0];
}
</preformatted></para><para>There are separate functions for floating-point, Q15, and Q31 data types. </para>    </detaileddescription>
  </compounddef>
</doxygen>
